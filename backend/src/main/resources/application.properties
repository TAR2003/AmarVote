spring.application.name=amarvote

# Use the direct URL from environment variable
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA/Hibernate Properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Timezone Configuration - Force UTC for all database operations
spring.jpa.properties.hibernate.jdbc.time_zone=UTC

server.forward-headers-strategy=framework

deepseek.api.url=https://openrouter.ai/api/v1/chat/completions
deepseek.api.key=${DEEPSEEK_API_KEY}

# RAG Service Configuration
rag.service.url=${RAG_SERVICE_URL}

# ElectionGuard Service Configuration
# API Service - Fast user-facing operations (setup_guardians, create_encrypted_ballot, benaloh_challenge, encrypt, decrypt)
electionguard.api.url=${ELECTIONGUARD_API_URL:http://electionguard-api:5000}
# Worker Service - Heavy cryptographic operations (create_encrypted_tally, create_partial_decryption, create_compensated_decryption, combine_decryption_shares)
electionguard.worker.url=${ELECTIONGUARD_WORKER_URL:http://electionguard-worker:5001}
# Legacy base URL for backward compatibility (defaults to API service)
electionguard.base.url=${ELECTIONGUARD_API_URL:http://electionguard-api:5000}
electionguard.connection.timeout=10000
electionguard.socket.timeout=600000
electionguard.connection.request.timeout=10000

# RabbitMQ Worker Concurrency Configuration
# Set to 1-1 for sequential processing to prevent API slowdown and connection pool starvation
# The issue with higher concurrency is that worker tasks hold DB connections and ElectionGuard HTTP
# connections for long periods, starving the user-facing API of resources.
rabbitmq.worker.concurrency.min=2
rabbitmq.worker.concurrency.max=2
# Connection pool settings optimized for high-throughput ElectionGuard services
# CRITICAL: Keep these reasonable to prevent connection exhaustion
# Worker processes 1 chunk at a time, API needs connections for user requests
electionguard.max.connections=50
electionguard.max.per.route=25

# Resilience4j Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.electionguard.register-health-indicator=true
resilience4j.circuitbreaker.instances.electionguard.sliding-window-size=10
resilience4j.circuitbreaker.instances.electionguard.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.electionguard.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.electionguard.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.electionguard.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.electionguard.slow-call-duration-threshold=300s
resilience4j.circuitbreaker.instances.electionguard.slow-call-rate-threshold=80

# Resilience4j Retry Configuration
resilience4j.retry.instances.electionguard.max-attempts=3
resilience4j.retry.instances.electionguard.wait-duration=2s
resilience4j.retry.instances.electionguard.enable-exponential-backoff=true
resilience4j.retry.instances.electionguard.exponential-backoff-multiplier=2

# WebClient Configuration (DEPRECATED - using RestTemplate now)
webclient.buffer.size=10485760
webclient.timeout.response=300000

# Database connection pool - OPTIMIZED to prevent worker from starving API
# CRITICAL: Aggressive settings to prevent connection starvation and stale connections
# spring.datasource.hikari.connectionTestQuery=SELECT 1
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=10000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000
spring.datasource.hikari.leak-detection-threshold=30000
spring.datasource.hikari.validation-timeout=3000
# CRITICAL: Test connections on borrow to prevent stale connections causing slowdowns
spring.datasource.hikari.connection-test-query=SELECT 1

jwt.secret=${JWT_SECRET}
jwt.expiration=1800000

# Cookie Security Settings
# Set to false for local/LAN development over HTTP
# Set to true for production HTTPS deployment
cookie.secure=false

spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=amarvote2025@gmail.com
spring.mail.password=${MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
# Bypass SSL verification (only for testing!)
spring.mail.properties.mail.smtp.ssl.trust=*
spring.mail.properties.mail.smtp.ssl.protocols=TLSv1.2

# brevo.api.key=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
# brevo.sender.email=amarvote2025@gmail.com
# brevo.sender.name=AmarVote


# Server Configuration
server.port=8080
server.address=0.0.0.0

# Async request timeout (5 minutes for computationally intensive operations)
spring.mvc.async.request-timeout=300000

# Async Execution for Chunk Processing
spring.task.execution.pool.core-size=20
spring.task.execution.pool.max-size=50
spring.task.execution.pool.queue-capacity=500
spring.task.execution.pool.keep-alive=60s
spring.task.execution.thread-name-prefix=chunk-processor-

# Multipart File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# RabbitMQ Configuration
spring.rabbitmq.host=${RABBITMQ_HOST:rabbitmq}
spring.rabbitmq.port=${RABBITMQ_PORT:5672}
spring.rabbitmq.username=${RABBITMQ_USERNAME:guest}
spring.rabbitmq.password=${RABBITMQ_PASSWORD:guest}
spring.rabbitmq.connection-timeout=30000
spring.rabbitmq.requested-heartbeat=60
spring.servlet.multipart.enabled=true

# Redis Configuration for secure temporary credential storage
# Redis stores sensitive data in-memory with automatic expiration (TTL)
# Industry standard for temporary secrets, session data, and cache
spring.data.redis.host=${SPRING_REDIS_HOST:redis}
spring.data.redis.port=${SPRING_REDIS_PORT:6379}
spring.data.redis.password=${SPRING_REDIS_PASSWORD:}
spring.data.redis.timeout=5000
spring.data.redis.lettuce.pool.max-active=20
spring.data.redis.lettuce.pool.max-idle=10
spring.data.redis.lettuce.pool.min-idle=5

# RAG Service Configuration (5 minutes timeout)
rag.service.timeout=300000


# Blockchain Service Configuration
blockchain.service.url=${BLOCKCHAIN_SERVICE_URL}

# Cloudinary Configuration
cloudinary.cloud_name=${CLOUDINARY_NAME}
cloudinary.api_key=${CLOUDINARY_KEY}
cloudinary.api_secret=${CLOUDINARY_SECRET}

# AmarVote Chunking Configuration
amarvote.chunking.chunk-size=50

# AmarVote OTP Configuration
amarvote.otp.validity-minutes=5

# AmarVote Credentials Configuration
# Directory for storing temporary credential files
# In production, use an absolute path or mounted volume
amarvote.credentials.directory=${CREDENTIALS_DIRECTORY:credentials}
# Enable secure deletion (overwrite files before deletion)
amarvote.credentials.secure-delete=true
# Maximum credential file size in MB
amarvote.credentials.max-file-size-mb=10

# Actuator & Prometheus Configuration
# Actuator & Prometheus Configuration
# Actuator & Prometheus Configuration (Spring Boot 3.5.0+)
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.prometheus.metrics.export.enabled=true
management.endpoint.health.show-details=when-authorized
management.endpoints.web.base-path=/actuator
# Add application label to metrics
management.metrics.tags.application=AmarVote Backend

